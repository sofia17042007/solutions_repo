{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Introduction and Motivation Significance of Studying Projectile Motion Projectile motion is a fundamental concept in physics that describes the motion of an object launched into the air, subject only to the force of gravity. Understanding projectile motion is crucial because it provides insights into: The behavior of objects in free-fall and how they travel through space. The effects of different forces, such as gravity and air resistance, on moving bodies. Predicting the trajectory of objects in various real-world scenarios. Projectile motion is not just a theoretical concept but a practical tool for engineers, scientists, and athletes who need to optimize performance in various applications. Practical Applications Studying projectile motion has a wide range of applications across different fields, including: Sports: Understanding projectile motion helps athletes optimize their performance in sports like soccer, basketball, and javelin throwing by adjusting angles and forces to achieve maximum range or accuracy. Engineering: Engineers use projectile motion principles to design ballistic trajectories, optimize water fountains, and even develop safety mechanisms in vehicles. Astrophysics and Space Exploration: The motion of rockets and space probes follows projectile motion principles, taking into account gravity and external forces. Military and Defense: The trajectory of missiles, artillery shells, and even drones is based on the principles of projectile motion. Key Parameters Affecting Projectile Motion Several parameters influence the behavior of a projectile: Initial velocity (v\u2080): Determines the overall motion, affecting both range and maximum height. Angle of projection (\u03b8): The launch angle plays a crucial role in optimizing the range and trajectory shape. Gravitational acceleration (g): The constant acceleration due to gravity affects the motion, typically taken as 9.81 m/s\u00b2 on Earth. Launch height (h): If the projectile is launched from a height, it alters the flight time and final landing position. Air resistance (optional consideration): In real-world scenarios, drag affects the motion but is often neglected in basic models. By analyzing how these parameters interact, we can develop accurate models to describe and predict projectile trajectories in different conditions. Theoretical Foundation Governing Equations of Motion Projectile motion is governed by Newton\u2019s second law of motion: \\[ F = ma \\] Since the only force acting on the projectile (in an idealized case) is gravity, the equations of motion can be derived by considering the motion separately in horizontal and vertical directions. Horizontal Motion No acceleration in the absence of air resistance: $$ a_x = 0 $$ Constant velocity: $$ v_x = v_0 \\cos\\theta $$ Displacement in time \\( t \\) : $$ x = v_0 \\cos\\theta \\cdot t $$ Vertical Motion change Acceleration due to gravity: $$ a_y = -g $$ Velocity as a function of time: $$ v_y = v_0 \\sin\\theta - g t $$ Displacement in time t : $$ y = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ Solving the Basic Differential Equations To describe the general motion, we solve the differential equations for velocity and displacement: Velocity equations: \\[ \\frac{dv_x}{dt} = 0 \\Rightarrow v_x = v_0 \\cos\\theta \\] \\[ \\frac{dv_y}{dt} = -g \\Rightarrow v_y = v_0 \\sin\\theta - g t \\] Displacement equations: \\[ \\frac{dx}{dt} = v_0 \\cos\\theta \\Rightarrow x = v_0 \\cos\\theta \\cdot t \\] \\[ \\frac{dy}{dt} = v_0 \\sin\\theta - g t \\Rightarrow y = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] These equations fully describe the motion of the projectile. Influence of Initial Conditions The trajectory of the projectile changes significantly depending on: Initial velocity (v\u2080): A higher velocity increases both the range and maximum height. Launch angle (\u03b8): Determines the shape of the trajectory and the distance covered. Launch height (h): If the projectile is launched from an elevated position, the total flight time increases. Gravitational acceleration (g): Affects downward motion, varying with location (e.g., Earth vs. Moon). By varying these conditions, we can model different scenarios and understand the diverse outcomes of projectile motion.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#introduction-and-motivation","text":"","title":"Introduction and Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#significance-of-studying-projectile-motion","text":"Projectile motion is a fundamental concept in physics that describes the motion of an object launched into the air, subject only to the force of gravity. Understanding projectile motion is crucial because it provides insights into: The behavior of objects in free-fall and how they travel through space. The effects of different forces, such as gravity and air resistance, on moving bodies. Predicting the trajectory of objects in various real-world scenarios. Projectile motion is not just a theoretical concept but a practical tool for engineers, scientists, and athletes who need to optimize performance in various applications.","title":"Significance of Studying Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications","text":"Studying projectile motion has a wide range of applications across different fields, including: Sports: Understanding projectile motion helps athletes optimize their performance in sports like soccer, basketball, and javelin throwing by adjusting angles and forces to achieve maximum range or accuracy. Engineering: Engineers use projectile motion principles to design ballistic trajectories, optimize water fountains, and even develop safety mechanisms in vehicles. Astrophysics and Space Exploration: The motion of rockets and space probes follows projectile motion principles, taking into account gravity and external forces. Military and Defense: The trajectory of missiles, artillery shells, and even drones is based on the principles of projectile motion.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-parameters-affecting-projectile-motion","text":"Several parameters influence the behavior of a projectile: Initial velocity (v\u2080): Determines the overall motion, affecting both range and maximum height. Angle of projection (\u03b8): The launch angle plays a crucial role in optimizing the range and trajectory shape. Gravitational acceleration (g): The constant acceleration due to gravity affects the motion, typically taken as 9.81 m/s\u00b2 on Earth. Launch height (h): If the projectile is launched from a height, it alters the flight time and final landing position. Air resistance (optional consideration): In real-world scenarios, drag affects the motion but is often neglected in basic models. By analyzing how these parameters interact, we can develop accurate models to describe and predict projectile trajectories in different conditions.","title":"Key Parameters Affecting Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations-of-motion","text":"Projectile motion is governed by Newton\u2019s second law of motion: \\[ F = ma \\] Since the only force acting on the projectile (in an idealized case) is gravity, the equations of motion can be derived by considering the motion separately in horizontal and vertical directions.","title":"Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"No acceleration in the absence of air resistance: $$ a_x = 0 $$ Constant velocity: $$ v_x = v_0 \\cos\\theta $$ Displacement in time \\( t \\) : $$ x = v_0 \\cos\\theta \\cdot t $$","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion-change","text":"Acceleration due to gravity: $$ a_y = -g $$ Velocity as a function of time: $$ v_y = v_0 \\sin\\theta - g t $$ Displacement in time t : $$ y = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$","title":"Vertical Motion change"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solving-the-basic-differential-equations","text":"To describe the general motion, we solve the differential equations for velocity and displacement: Velocity equations: \\[ \\frac{dv_x}{dt} = 0 \\Rightarrow v_x = v_0 \\cos\\theta \\] \\[ \\frac{dv_y}{dt} = -g \\Rightarrow v_y = v_0 \\sin\\theta - g t \\] Displacement equations: \\[ \\frac{dx}{dt} = v_0 \\cos\\theta \\Rightarrow x = v_0 \\cos\\theta \\cdot t \\] \\[ \\frac{dy}{dt} = v_0 \\sin\\theta - g t \\Rightarrow y = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] These equations fully describe the motion of the projectile.","title":"Solving the Basic Differential Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-initial-conditions","text":"The trajectory of the projectile changes significantly depending on: Initial velocity (v\u2080): A higher velocity increases both the range and maximum height. Launch angle (\u03b8): Determines the shape of the trajectory and the distance covered. Launch height (h): If the projectile is launched from an elevated position, the total flight time increases. Gravitational acceleration (g): Affects downward motion, varying with location (e.g., Earth vs. Moon). By varying these conditions, we can model different scenarios and understand the diverse outcomes of projectile motion.","title":"Influence of Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. The system demonstrates: - Simple harmonic motion - Resonance phenomena - Chaotic behavior - Quasiperiodic dynamics These phenomena are foundational for understanding real-world systems like driven oscillators, climate models, and mechanical structures under periodic stress. Theoretical Foundation The governing differential equation for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma\\frac{d\\theta}{dt} + \\omega_0^2\\sin\\theta = F\\cos(\\omega t) \\] Where: - \\(\\theta\\) : Angular displacement - \\(\\gamma\\) : Damping coefficient - \\(\\omega_0 = \\sqrt{g/L}\\) : Natural frequency - \\(F\\) : Driving amplitude - \\(\\omega\\) : Driving frequency Small-Angle Approximation For \\(\\theta \\ll 1\\) , \\(\\sin\\theta \\approx \\theta\\) : \\[ \\frac{d^2\\theta}{dt^2} + \\gamma\\frac{d\\theta}{dt} + \\omega_0^2\\theta = F\\cos(\\omega t) \\] Resonance Condition When \\(\\omega \\approx \\omega_0\\) , the system exhibits maximum energy transfer: \\[ \\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{2}} \\] Analysis of Dynamics Key parameters affecting behavior: 1. Damping coefficient ( \\(\\gamma\\) ) - Underdamped: \\(\\gamma < 2\\omega_0\\) - Critically damped: \\(\\gamma = 2\\omega_0\\) - Overdamped: \\(\\gamma > 2\\omega_0\\) Driving amplitude ( \\(F\\) ) Small \\(F\\) : Linear response Large \\(F\\) : Nonlinear effects and chaos Driving frequency ( \\(\\omega\\) ) Subharmonic response Superharmonic response Chaotic regimes Practical Applications Energy harvesting devices Suspension bridge dynamics Oscillating circuits (RLC analogs) Biomechanical systems Implementation (Python Example) import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt def forced_pendulum(t, y, gamma, omega0, F, omega): theta, omega = y dydt = [omega, -gamma*omega - omega0**2*np.sin(theta) + F*np.cos(omega*t)] return dydt # Parameters gamma = 0.5 omega0 = 1.0 F = 1.2 omega = 0.8 # Solve sol = solve_ivp(forced_pendulum, [0, 100], [0.1, 0], args=(gamma, omega0, F, omega), dense_output=True) # Plot t = np.linspace(0, 100, 3000) theta = sol.sol(t)[0] plt.plot(t, theta) plt.xlabel('Time') plt.ylabel('\u03b8(t)') plt.title('Forced Damped Pendulum') plt.show() Graphical Analysis Phase Portraits : Plotting angular velocity vs. angular displacement can reveal periodic, quasiperiodic, or chaotic behavior. Poincar\u00e9 Sections : Sampling the phase space at regular intervals provides insight into chaotic transitions. Bifurcation Diagrams : Tracking fixed points as parameters vary helps understand the transition to chaos. Practical Applications Energy Harvesting : Used in pendulum-based energy harvesting systems. Suspension Bridges : Analyzing resonance effects to prevent structural failure. Electrical Circuits : Analogous to driven RLC circuits in electronics. Conclusion This study bridges theoretical analysis with computational exploration, providing insights into oscillatory systems in physics and engineering. Further extensions can include nonlinear damping effects or non-periodic driving forces to investigate more complex dynamics.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. The system demonstrates: - Simple harmonic motion - Resonance phenomena - Chaotic behavior - Quasiperiodic dynamics These phenomena are foundational for understanding real-world systems like driven oscillators, climate models, and mechanical structures under periodic stress.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation","text":"The governing differential equation for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma\\frac{d\\theta}{dt} + \\omega_0^2\\sin\\theta = F\\cos(\\omega t) \\] Where: - \\(\\theta\\) : Angular displacement - \\(\\gamma\\) : Damping coefficient - \\(\\omega_0 = \\sqrt{g/L}\\) : Natural frequency - \\(F\\) : Driving amplitude - \\(\\omega\\) : Driving frequency","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For \\(\\theta \\ll 1\\) , \\(\\sin\\theta \\approx \\theta\\) : \\[ \\frac{d^2\\theta}{dt^2} + \\gamma\\frac{d\\theta}{dt} + \\omega_0^2\\theta = F\\cos(\\omega t) \\]","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"When \\(\\omega \\approx \\omega_0\\) , the system exhibits maximum energy transfer: \\[ \\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{2}} \\]","title":"Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analysis-of-dynamics","text":"Key parameters affecting behavior: 1. Damping coefficient ( \\(\\gamma\\) ) - Underdamped: \\(\\gamma < 2\\omega_0\\) - Critically damped: \\(\\gamma = 2\\omega_0\\) - Overdamped: \\(\\gamma > 2\\omega_0\\) Driving amplitude ( \\(F\\) ) Small \\(F\\) : Linear response Large \\(F\\) : Nonlinear effects and chaos Driving frequency ( \\(\\omega\\) ) Subharmonic response Superharmonic response Chaotic regimes","title":"Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications","text":"Energy harvesting devices Suspension bridge dynamics Oscillating circuits (RLC analogs) Biomechanical systems","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#implementation-python-example","text":"import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt def forced_pendulum(t, y, gamma, omega0, F, omega): theta, omega = y dydt = [omega, -gamma*omega - omega0**2*np.sin(theta) + F*np.cos(omega*t)] return dydt # Parameters gamma = 0.5 omega0 = 1.0 F = 1.2 omega = 0.8 # Solve sol = solve_ivp(forced_pendulum, [0, 100], [0.1, 0], args=(gamma, omega0, F, omega), dense_output=True) # Plot t = np.linspace(0, 100, 3000) theta = sol.sol(t)[0] plt.plot(t, theta) plt.xlabel('Time') plt.ylabel('\u03b8(t)') plt.title('Forced Damped Pendulum') plt.show()","title":"Implementation (Python Example)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#graphical-analysis","text":"Phase Portraits : Plotting angular velocity vs. angular displacement can reveal periodic, quasiperiodic, or chaotic behavior. Poincar\u00e9 Sections : Sampling the phase space at regular intervals provides insight into chaotic transitions. Bifurcation Diagrams : Tracking fixed points as parameters vary helps understand the transition to chaos.","title":"Graphical Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications_1","text":"Energy Harvesting : Used in pendulum-based energy harvesting systems. Suspension Bridges : Analyzing resonance effects to prevent structural failure. Electrical Circuits : Analogous to driven RLC circuits in electronics.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"This study bridges theoretical analysis with computational exploration, providing insights into oscillatory systems in physics and engineering. Further extensions can include nonlinear damping effects or non-periodic driving forces to investigate more complex dynamics.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Kepler's Third Law: Orbital Period and Radius Introduction The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is fundamental in celestial mechanics. This law helps in determining planetary motions and understanding gravitational interactions in space. Mathematical Derivation Kepler's Third Law states that: \\(T^2 \\propto R^3\\) For circular orbits, using Newton's version of Kepler's Third Law: \\(T = 2\\pi \\sqrt{\\frac{R^3}{GM}}\\) where: - \\(T\\) is the orbital period, - \\(R\\) is the orbital radius, - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body. Computational Model Below is a Python script to compute and visualize the relationship: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) # Function to compute orbital period def orbital_period(radius, central_mass): return 2 * np.pi * np.sqrt(radius**3 / (G * central_mass)) # Generate data for various orbital radii radii = np.linspace(1.1 * R_earth, 10 * R_earth, 100) # Orbital radii periods = orbital_period(radii, M_earth) # Verify Kepler's Third Law (T^2 vs R^3) radii_cubed = radii**3 periods_squared = periods**2 # Plot T^2 vs R^3 plt.figure(figsize=(8, 6)) plt.plot(radii_cubed, periods_squared, label=\"$T^2$ vs $R^3$\", color='blue') plt.xlabel(\"Orbital Radius Cubed ($m^3$)\") plt.ylabel(\"Orbital Period Squared ($s^2$)\") plt.title(\"Kepler's Third Law Verification\") plt.legend() plt.grid() plt.show() # Simulate circular orbit theta = np.linspace(0, 2*np.pi, 100) x = radii[50] * np.cos(theta) y = radii[50] * np.sin(theta) plt.figure(figsize=(6,6)) plt.plot(x, y, label='Orbit', color='green') plt.scatter(0, 0, color='red', label='Central Body (Earth)') plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Circular Orbit Visualization\") plt.legend() plt.grid() plt.axis('equal') plt.show() Results & Discussion Kepler\u2019s Third Law Verification The plot of \\( \\(T^2 \\text{ vs } R^3\\) \\) demonstrates a linear relationship, confirming: \\( \\(\\boxed{T^2 \\propto R^3}\\) \\) This aligns with Kepler\u2019s empirical observations and Newton\u2019s gravitational theory. Circular Orbit Assumptions The simulated orbit (green curve) assumes: A perfectly circular path ( \\(e = 0\\) ). Negligible perturbations (e.g., atmospheric drag, third-body effects). A central mass ( \\(M_{\\text{Earth}}\\) ) dominating the system. Extensions to Elliptical Orbits For elliptical orbits ( \\(0 < e < 1\\) ), the law generalizes to: \\( \\(\\boxed{T^2 = \\frac{4\\pi^2}{GM} a^3}\\) \\) where \\(a\\) is the semi-major axis. Advanced celestial mechanics (e.g., Lagrange\u2019s planetary equations) are required for precise modeling. Conclusion Kepler\u2019s Third Law ( \\(T^2 \\propto R^3\\) ) remains foundational for: - Satellite deployment (e.g., geostationary orbit calculations). - Space mission planning","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-orbital-period-and-radius","text":"","title":"Kepler's Third Law: Orbital Period and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is fundamental in celestial mechanics. This law helps in determining planetary motions and understanding gravitational interactions in space.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mathematical-derivation","text":"Kepler's Third Law states that: \\(T^2 \\propto R^3\\) For circular orbits, using Newton's version of Kepler's Third Law: \\(T = 2\\pi \\sqrt{\\frac{R^3}{GM}}\\) where: - \\(T\\) is the orbital period, - \\(R\\) is the orbital radius, - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body.","title":"Mathematical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-model","text":"Below is a Python script to compute and visualize the relationship: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) # Function to compute orbital period def orbital_period(radius, central_mass): return 2 * np.pi * np.sqrt(radius**3 / (G * central_mass)) # Generate data for various orbital radii radii = np.linspace(1.1 * R_earth, 10 * R_earth, 100) # Orbital radii periods = orbital_period(radii, M_earth) # Verify Kepler's Third Law (T^2 vs R^3) radii_cubed = radii**3 periods_squared = periods**2 # Plot T^2 vs R^3 plt.figure(figsize=(8, 6)) plt.plot(radii_cubed, periods_squared, label=\"$T^2$ vs $R^3$\", color='blue') plt.xlabel(\"Orbital Radius Cubed ($m^3$)\") plt.ylabel(\"Orbital Period Squared ($s^2$)\") plt.title(\"Kepler's Third Law Verification\") plt.legend() plt.grid() plt.show() # Simulate circular orbit theta = np.linspace(0, 2*np.pi, 100) x = radii[50] * np.cos(theta) y = radii[50] * np.sin(theta) plt.figure(figsize=(6,6)) plt.plot(x, y, label='Orbit', color='green') plt.scatter(0, 0, color='red', label='Central Body (Earth)') plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Circular Orbit Visualization\") plt.legend() plt.grid() plt.axis('equal') plt.show()","title":"Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#results-discussion","text":"Kepler\u2019s Third Law Verification The plot of \\( \\(T^2 \\text{ vs } R^3\\) \\) demonstrates a linear relationship, confirming: \\( \\(\\boxed{T^2 \\propto R^3}\\) \\) This aligns with Kepler\u2019s empirical observations and Newton\u2019s gravitational theory. Circular Orbit Assumptions The simulated orbit (green curve) assumes: A perfectly circular path ( \\(e = 0\\) ). Negligible perturbations (e.g., atmospheric drag, third-body effects). A central mass ( \\(M_{\\text{Earth}}\\) ) dominating the system. Extensions to Elliptical Orbits For elliptical orbits ( \\(0 < e < 1\\) ), the law generalizes to: \\( \\(\\boxed{T^2 = \\frac{4\\pi^2}{GM} a^3}\\) \\) where \\(a\\) is the semi-major axis. Advanced celestial mechanics (e.g., Lagrange\u2019s planetary equations) are required for precise modeling.","title":"Results &amp; Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law ( \\(T^2 \\propto R^3\\) ) remains foundational for: - Satellite deployment (e.g., geostationary orbit calculations). - Space mission planning","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation Understanding escape and cosmic velocities is vital in celestial mechanics and space exploration. These thresholds determine the minimum speeds required for: Staying in orbit (First Cosmic Velocity) Escaping a planet's gravity (Second Cosmic Velocity) Leaving a star system (Third Cosmic Velocity) These concepts are essential for satellite deployment, interplanetary travel, and planning future interstellar missions. Definitions 1. First Cosmic Velocity (Orbital Velocity) The minimum velocity required to maintain a circular orbit just above a celestial body's surface: \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Where: \\[ G : Gravitational constant (6.674 \\times 10^{-11} \\, \\text{m}^3/\\text{kg} \\cdot \\text{s}^2)\\] \\[M : Mass of the celestial body\\] \\[ R : Radius of the celestial body\\] 2. Second Cosmic Velocity (Escape Velocity) The minimum velocity needed to completely escape the gravitational field of a celestial body: \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\cdot v_1 \\] 3. Third Cosmic Velocity The minimum velocity needed to escape the gravitational influence of a star (e.g., the Sun) from a planet\u2019s orbit: \\[v_3 = \\sqrt{v_{\\text{planet}}^2 + \\frac{2GM_{\\text{sun}}}{r}}\\] Where: \\[( v_{\\text{planet}}): Orbital speed of the planet around the Sun\\] \\[ M_{\\text{sun}} : Mass of the Sun\\] \\[r : Distance from the Sun\\] Python Implementation import matplotlib.pyplot as plt import numpy as np # Constants G = 6.67430e-11 # gravitational constant [m^3 kg^-1 s^-2] # Celestial bodies data: name, mass (kg), radius (m), orbital velocity around the sun (m/s), distance from sun (m) bodies = { \"Earth\": { \"mass\": 5.972e24, \"radius\": 6.371e6, \"orbital_velocity\": 29.78e3, \"distance_from_sun\": 1.496e11 }, \"Mars\": { \"mass\": 6.417e23, \"radius\": 3.389e6, \"orbital_velocity\": 24.07e3, \"distance_from_sun\": 2.279e11 }, \"Jupiter\": { \"mass\": 1.898e27, \"radius\": 6.9911e7, \"orbital_velocity\": 13.07e3, \"distance_from_sun\": 7.785e11 } } # Sun data mass_sun = 1.989e30 # Function to calculate velocities def calculate_velocities(mass, radius, orbital_velocity, distance_from_sun): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2 * G * mass / radius) v3 = np.sqrt(orbital_velocity**2 + (2 * G * mass_sun / distance_from_sun)) return v1, v2, v3 # Collect data names, v1_list, v2_list, v3_list = [], [], [], [] for name, data in bodies.items(): v1, v2, v3 = calculate_velocities(data[\"mass\"], data[\"radius\"], data[\"orbital_velocity\"], data[\"distance_from_sun\"]) names.append(name) v1_list.append(v1 / 1000) # convert to km/s v2_list.append(v2 / 1000) v3_list.append(v3 / 1000) # Plotting x = np.arange(len(names)) width = 0.25 plt.figure(figsize=(10,6)) plt.bar(x - width, v1_list, width, label='First Cosmic Velocity') plt.bar(x, v2_list, width, label='Second Cosmic Velocity') plt.bar(x + width, v3_list, width, label='Third Cosmic Velocity') plt.xticks(x, names) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Celestial Bodies') plt.legend() plt.grid(True) plt.tight_layout() plt.show() Analysis Earth : First Cosmic Velocity : ~7.9 km/s \u2014 the minimum speed to enter low Earth orbit. Second Cosmic Velocity : ~11.2 km/s \u2014 required to escape Earth\u2019s gravity. Third Cosmic Velocity : ~42.1 km/s \u2014 needed to leave the Solar System from Earth\u2019s orbit. Mars : First Cosmic Velocity : ~3.6 km/s Second Cosmic Velocity : ~5.0 km/s Third Cosmic Velocity : ~34.1 km/s \u2014 lower than Earth\u2019s due to weaker solar gravity at Mars\u2019 distance. Jupiter : First Cosmic Velocity : ~18.5 km/s Second Cosmic Velocity : ~59.5 km/s \u2014 extremely high due to Jupiter\u2019s massive gravity. Third Cosmic Velocity : ~24.1 km/s \u2014 lower than Earth\u2019s because Jupiter is farther from the Sun. Importance in Space Exploration Artificial Satellites : Must reach at least the first cosmic velocity to maintain orbit. Interplanetary Missions : Require second cosmic velocity to break free from a planet's gravitational field. Gravity Assists : Used to increase velocity without using fuel, crucial for reaching or exceeding third cosmic velocity. Interstellar Travel : Involves surpassing third cosmic velocity, demanding advanced propulsion systems like ion drives, solar sails, or nuclear propulsion. Fuel Optimization : Knowing the exact velocities allows for precise and energy-efficient mission planning. Conclusion Understanding cosmic velocities is fundamental to spaceflight and mission design. They define the energy thresholds for different phases of space exploration: First Cosmic Velocity : Required for stable orbit. Second Cosmic Velocity : Required to escape a planet. Third Cosmic Velocity : Required to escape a star system. These principles are the foundation of astrodynamics and are key to designing efficient, scalable missions that can reach other planets\u2014and eventually other stars.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Understanding escape and cosmic velocities is vital in celestial mechanics and space exploration. These thresholds determine the minimum speeds required for: Staying in orbit (First Cosmic Velocity) Escaping a planet's gravity (Second Cosmic Velocity) Leaving a star system (Third Cosmic Velocity) These concepts are essential for satellite deployment, interplanetary travel, and planning future interstellar missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"The minimum velocity required to maintain a circular orbit just above a celestial body's surface: \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Where: \\[ G : Gravitational constant (6.674 \\times 10^{-11} \\, \\text{m}^3/\\text{kg} \\cdot \\text{s}^2)\\] \\[M : Mass of the celestial body\\] \\[ R : Radius of the celestial body\\]","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"The minimum velocity needed to completely escape the gravitational field of a celestial body: \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\cdot v_1 \\]","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity","text":"The minimum velocity needed to escape the gravitational influence of a star (e.g., the Sun) from a planet\u2019s orbit: \\[v_3 = \\sqrt{v_{\\text{planet}}^2 + \\frac{2GM_{\\text{sun}}}{r}}\\] Where: \\[( v_{\\text{planet}}): Orbital speed of the planet around the Sun\\] \\[ M_{\\text{sun}} : Mass of the Sun\\] \\[r : Distance from the Sun\\]","title":"3. Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-implementation","text":"import matplotlib.pyplot as plt import numpy as np # Constants G = 6.67430e-11 # gravitational constant [m^3 kg^-1 s^-2] # Celestial bodies data: name, mass (kg), radius (m), orbital velocity around the sun (m/s), distance from sun (m) bodies = { \"Earth\": { \"mass\": 5.972e24, \"radius\": 6.371e6, \"orbital_velocity\": 29.78e3, \"distance_from_sun\": 1.496e11 }, \"Mars\": { \"mass\": 6.417e23, \"radius\": 3.389e6, \"orbital_velocity\": 24.07e3, \"distance_from_sun\": 2.279e11 }, \"Jupiter\": { \"mass\": 1.898e27, \"radius\": 6.9911e7, \"orbital_velocity\": 13.07e3, \"distance_from_sun\": 7.785e11 } } # Sun data mass_sun = 1.989e30 # Function to calculate velocities def calculate_velocities(mass, radius, orbital_velocity, distance_from_sun): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2 * G * mass / radius) v3 = np.sqrt(orbital_velocity**2 + (2 * G * mass_sun / distance_from_sun)) return v1, v2, v3 # Collect data names, v1_list, v2_list, v3_list = [], [], [], [] for name, data in bodies.items(): v1, v2, v3 = calculate_velocities(data[\"mass\"], data[\"radius\"], data[\"orbital_velocity\"], data[\"distance_from_sun\"]) names.append(name) v1_list.append(v1 / 1000) # convert to km/s v2_list.append(v2 / 1000) v3_list.append(v3 / 1000) # Plotting x = np.arange(len(names)) width = 0.25 plt.figure(figsize=(10,6)) plt.bar(x - width, v1_list, width, label='First Cosmic Velocity') plt.bar(x, v2_list, width, label='Second Cosmic Velocity') plt.bar(x + width, v3_list, width, label='Third Cosmic Velocity') plt.xticks(x, names) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Celestial Bodies') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#analysis","text":"Earth : First Cosmic Velocity : ~7.9 km/s \u2014 the minimum speed to enter low Earth orbit. Second Cosmic Velocity : ~11.2 km/s \u2014 required to escape Earth\u2019s gravity. Third Cosmic Velocity : ~42.1 km/s \u2014 needed to leave the Solar System from Earth\u2019s orbit. Mars : First Cosmic Velocity : ~3.6 km/s Second Cosmic Velocity : ~5.0 km/s Third Cosmic Velocity : ~34.1 km/s \u2014 lower than Earth\u2019s due to weaker solar gravity at Mars\u2019 distance. Jupiter : First Cosmic Velocity : ~18.5 km/s Second Cosmic Velocity : ~59.5 km/s \u2014 extremely high due to Jupiter\u2019s massive gravity. Third Cosmic Velocity : ~24.1 km/s \u2014 lower than Earth\u2019s because Jupiter is farther from the Sun.","title":"Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"Artificial Satellites : Must reach at least the first cosmic velocity to maintain orbit. Interplanetary Missions : Require second cosmic velocity to break free from a planet's gravitational field. Gravity Assists : Used to increase velocity without using fuel, crucial for reaching or exceeding third cosmic velocity. Interstellar Travel : Involves surpassing third cosmic velocity, demanding advanced propulsion systems like ion drives, solar sails, or nuclear propulsion. Fuel Optimization : Knowing the exact velocities allows for precise and energy-efficient mission planning.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Understanding cosmic velocities is fundamental to spaceflight and mission design. They define the energy thresholds for different phases of space exploration: First Cosmic Velocity : Required for stable orbit. Second Cosmic Velocity : Required to escape a planet. Third Cosmic Velocity : Required to escape a star system. These principles are the foundation of astrodynamics and are key to designing efficient, scalable missions that can reach other planets\u2014and eventually other stars.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 \ud83c\udf0d Trajectories of a Freely Released Payload Near Earth \ud83d\udccc Motivation When a payload is released from a spacecraft, its trajectory can vary greatly depending on its initial velocity and position. Whether it falls back to Earth, enters orbit, or escapes into space depends on classical orbital mechanics and Newtonian gravity. This simulation explores different outcomes of payload releases near Earth. \ud83c\udfaf Objectives Analyze trajectory types: elliptical , parabolic , hyperbolic Simulate and visualize the payload\u2019s motion under Earth\u2019s gravity Understand relationships to real-world missions: orbital insertion , reentry , or escape \ud83c\udf0c Theoretical Background Newton\u2019s Law of Gravitation \\[ F = \\frac{GMm}{r^2} \\] Newton's Second Law \\[ \\vec{a} = \\frac{F}{m} = -\\frac{GM}{r^2} \\hat{r} \\] Equations of Motion in 2D \\[ \\frac{d^2x}{dt^2} = -\\frac{GMx}{(x^2 + y^2)^{3/2}}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{(x^2 + y^2)^{3/2}} \\] These equations are integrated numerically using the Runge-Kutta method. \ud83c\udf0d Earth Constants \\( G = 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) \\( R = 6.371 \\times 10^6 \\, \\text{m} \\) (Earth radius) \ud83d\udc0d Python Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Earth mass R_earth = 6.371e6 # Earth radius # Gravity function def gravity(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] # Initial conditions altitude = 300e3 # 300 km above surface r0 = R_earth + altitude v_circular = np.sqrt(G * M / r0) # Try different initial velocities v_multipliers = [0.5, 1.0, 1.2] colors = ['blue', 'green', 'red'] labels = ['Suborbital (Elliptical)', 'Stable Orbit (Circular)', 'Escape (Hyperbolic)'] # Time span and evaluation points t_span = (0, 6000) t_eval = np.linspace(*t_span, 5000) # Plot Earth theta = np.linspace(0, 2*np.pi, 100) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) plt.figure(figsize=(8, 8)) plt.plot(earth_x, earth_y, 'k', label='Earth') # Simulate trajectories for i, mult in enumerate(v_multipliers): vx0 = 0 vy0 = mult * v_circular y0 = [r0, vx0, 0, vy0] sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) plt.plot(sol.y[0], sol.y[2], color=colors[i], label=labels[i]) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Payload Trajectories Near Earth') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"\ud83c\udf0d Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a spacecraft, its trajectory can vary greatly depending on its initial velocity and position. Whether it falls back to Earth, enters orbit, or escapes into space depends on classical orbital mechanics and Newtonian gravity. This simulation explores different outcomes of payload releases near Earth.","title":"\ud83d\udccc Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objectives","text":"Analyze trajectory types: elliptical , parabolic , hyperbolic Simulate and visualize the payload\u2019s motion under Earth\u2019s gravity Understand relationships to real-world missions: orbital insertion , reentry , or escape","title":"\ud83c\udfaf Objectives"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"","title":"\ud83c\udf0c Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"\\[ F = \\frac{GMm}{r^2} \\]","title":"Newton\u2019s Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-second-law","text":"\\[ \\vec{a} = \\frac{F}{m} = -\\frac{GM}{r^2} \\hat{r} \\]","title":"Newton's Second Law"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion-in-2d","text":"\\[ \\frac{d^2x}{dt^2} = -\\frac{GMx}{(x^2 + y^2)^{3/2}}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{(x^2 + y^2)^{3/2}} \\] These equations are integrated numerically using the Runge-Kutta method.","title":"Equations of Motion in 2D"},{"location":"1%20Physics/2%20Gravity/Problem_3/#earth-constants","text":"\\( G = 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) \\( R = 6.371 \\times 10^6 \\, \\text{m} \\) (Earth radius)","title":"\ud83c\udf0d Earth Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Earth mass R_earth = 6.371e6 # Earth radius # Gravity function def gravity(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] # Initial conditions altitude = 300e3 # 300 km above surface r0 = R_earth + altitude v_circular = np.sqrt(G * M / r0) # Try different initial velocities v_multipliers = [0.5, 1.0, 1.2] colors = ['blue', 'green', 'red'] labels = ['Suborbital (Elliptical)', 'Stable Orbit (Circular)', 'Escape (Hyperbolic)'] # Time span and evaluation points t_span = (0, 6000) t_eval = np.linspace(*t_span, 5000) # Plot Earth theta = np.linspace(0, 2*np.pi, 100) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) plt.figure(figsize=(8, 8)) plt.plot(earth_x, earth_y, 'k', label='Earth') # Simulate trajectories for i, mult in enumerate(v_multipliers): vx0 = 0 vy0 = mult * v_circular y0 = [r0, vx0, 0, vy0] sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) plt.plot(sol.y[0], sol.y[2], color=colors[i], label=labels[i]) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Payload Trajectories Near Earth') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udc0d Python Code"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 \ud83c\udf0a Interference Patterns on a Water Surface \ud83c\udfaf Motivation Interference patterns from multiple wave sources on a water surface reveal core principles of wave physics \u2014 especially how waves reinforce or cancel each other. This project simulates the interference of circular waves from point sources placed at the vertices of a regular polygon and visualizes their complex overlapping patterns. \ud83d\udcd0 Task Summary Select a regular polygon (e.g., square). Place point wave sources at its vertices. Model each wave as a circular sinusoidal wave. Apply the superposition principle to simulate interference. Visualize the pattern of constructive and destructive interference. \ud83e\uddee Theoretical Background Single Wave Disturbance A circular wave from a point source at $$ \\vec{r}_0 $$ is: \\[ \\psi(\\vec{r}, t) = A \\cdot \\sin(kr - \\omega t + \\phi) \\] Where: $$ A $$ is the amplitude $$ k = \\frac{2\\pi}{\\lambda} $$ is the wave number $$ omega = 2\\pi f $$is the angular frequency $$ r = |\\vec{r} - \\vec{r}_0| $$ is distance to the observation point $$ \\phi $$ is the phase offset Superposition Principle For $$ N $$ sources: \\[ Psi(\\vec{r}, t) = \\sum_{i=1}^{N} A \\cdot \\sin(k |\\vec{r} - \\vec{r}_i| - \\omega t) \\] \ud83d\udc0d Python Code for Square Interference ```python import numpy as np import matplotlib.pyplot as plt # Parameters A = 1 # amplitude wavelength = 1.0 # in meters frequency = 1.0 # in Hz k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency t = 0 # snapshot in time # Regular polygon parameters N_sources = 5 # Change this to 3 (triangle), 4 (square), 6 (hexagon), etc. radius = 2.0 # Distance from center to each source # Grid for plotting x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Calculate positions of sources angles = np.linspace(0, 2 * np.pi, N_sources, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Initialize total wave eta_total = np.zeros_like(X) # Superposition of waves from all sources for sx, sy in source_positions: R = np.sqrt((X - sx)**2 + (Y - sy)**2) R[R == 0] = 1e-6 # prevent division by zero eta_total += A * np.cos(k * R - omega * t) # Plotting plt.figure(figsize=(8, 8)) plt.contourf(X, Y, eta_total, levels=100, cmap='seismic') plt.colorbar(label='Wave Displacement') plt.scatter(*zip(*source_positions), color='black', marker='x', label='Sources') plt.title(f'Water Surface Interference Pattern ({N_sources}-gon)') plt.xlabel('x [m]') plt.ylabel('y [m]') plt.axis('equal') plt.legend() plt.grid(False) plt.tight_layout() plt.show() \ud83d\udcc8 Interpretation Blue (0.5\u00d7 circular velocity) : The payload follows an elliptical suborbital trajectory and eventually reenters Earth's atmosphere. Green (1.0\u00d7 circular velocity) : The payload maintains a stable circular orbit around Earth. This is the ideal velocity for low Earth orbit (LEO). Red (1.2\u00d7 circular velocity) : The payload exceeds escape velocity, following a hyperbolic trajectory , and escapes Earth's gravitational influence. \ud83d\ude80 Conclusion This simulation demonstrates how a payload's initial speed determines its fate: Speeds below orbital velocity result in reentry or crash . Speeds equal to orbital velocity yield sustained orbit . Speeds above escape velocity lead to departure from Earth\u2019s gravity . Understanding these dynamics is crucial for mission planning, satellite deployment, and interplanetary exploration.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference patterns from multiple wave sources on a water surface reveal core principles of wave physics \u2014 especially how waves reinforce or cancel each other. This project simulates the interference of circular waves from point sources placed at the vertices of a regular polygon and visualizes their complex overlapping patterns.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task-summary","text":"Select a regular polygon (e.g., square). Place point wave sources at its vertices. Model each wave as a circular sinusoidal wave. Apply the superposition principle to simulate interference. Visualize the pattern of constructive and destructive interference.","title":"\ud83d\udcd0 Task Summary"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-background","text":"","title":"\ud83e\uddee Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#single-wave-disturbance","text":"A circular wave from a point source at $$ \\vec{r}_0 $$ is: \\[ \\psi(\\vec{r}, t) = A \\cdot \\sin(kr - \\omega t + \\phi) \\] Where: $$ A $$ is the amplitude $$ k = \\frac{2\\pi}{\\lambda} $$ is the wave number $$ omega = 2\\pi f $$is the angular frequency $$ r = |\\vec{r} - \\vec{r}_0| $$ is distance to the observation point $$ \\phi $$ is the phase offset","title":"Single Wave Disturbance"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-principle","text":"For $$ N $$ sources: \\[ Psi(\\vec{r}, t) = \\sum_{i=1}^{N} A \\cdot \\sin(k |\\vec{r} - \\vec{r}_i| - \\omega t) \\]","title":"Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code-for-square-interference","text":"```python import numpy as np import matplotlib.pyplot as plt # Parameters A = 1 # amplitude wavelength = 1.0 # in meters frequency = 1.0 # in Hz k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency t = 0 # snapshot in time # Regular polygon parameters N_sources = 5 # Change this to 3 (triangle), 4 (square), 6 (hexagon), etc. radius = 2.0 # Distance from center to each source # Grid for plotting x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Calculate positions of sources angles = np.linspace(0, 2 * np.pi, N_sources, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Initialize total wave eta_total = np.zeros_like(X) # Superposition of waves from all sources for sx, sy in source_positions: R = np.sqrt((X - sx)**2 + (Y - sy)**2) R[R == 0] = 1e-6 # prevent division by zero eta_total += A * np.cos(k * R - omega * t) # Plotting plt.figure(figsize=(8, 8)) plt.contourf(X, Y, eta_total, levels=100, cmap='seismic') plt.colorbar(label='Wave Displacement') plt.scatter(*zip(*source_positions), color='black', marker='x', label='Sources') plt.title(f'Water Surface Interference Pattern ({N_sources}-gon)') plt.xlabel('x [m]') plt.ylabel('y [m]') plt.axis('equal') plt.legend() plt.grid(False) plt.tight_layout() plt.show()","title":"\ud83d\udc0d Python Code for Square Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#interpretation","text":"Blue (0.5\u00d7 circular velocity) : The payload follows an elliptical suborbital trajectory and eventually reenters Earth's atmosphere. Green (1.0\u00d7 circular velocity) : The payload maintains a stable circular orbit around Earth. This is the ideal velocity for low Earth orbit (LEO). Red (1.2\u00d7 circular velocity) : The payload exceeds escape velocity, following a hyperbolic trajectory , and escapes Earth's gravitational influence.","title":"\ud83d\udcc8 Interpretation"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation demonstrates how a payload's initial speed determines its fate: Speeds below orbital velocity result in reentry or crash . Speeds equal to orbital velocity yield sustained orbit . Speeds above escape velocity lead to departure from Earth\u2019s gravity . Understanding these dynamics is crucial for mission planning, satellite deployment, and interplanetary exploration.","title":"\ud83d\ude80 Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \u26a1 Electromagnetism: Lorentz Force Simulation \ud83e\uddf2 Motivation The Lorentz force determines the motion of a charged particle in electric and magnetic fields: \\[vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This principle governs systems such as: - Cyclotrons & Synchrotrons (particle accelerators) - Mass spectrometers - Plasma confinement in tokamaks - Astrophysical jets and solar wind interactions By simulating this force, we gain intuitive insight into how fields control particle motion in real applications. \ud83d\udd27 Task Overview 1. Applications of Lorentz Force System Role of E and B fields Cyclotron Uses a B field to bend paths and an E field to accelerate particles Mass Spectrometer Separates particles based on mass-to-charge ratio using B field Plasma Confinement Magnetic fields trap hot plasma in fusion devices like tokamaks 2. Particle Motion Simulation We solve: \\[ \\frac{d\\vec{v}}{dt} = \\frac{q}{m} (\\vec{E} + \\vec{v} \\times \\vec{B}), \\quad \\frac{d\\vec{r}}{dt} = \\vec{v} \\] Using numerical integration (Euler or Runge-Kutta), we simulate 3 cases: Uniform magnetic field (circular/helical motion) Uniform electric + magnetic fields (helical drift) Crossed \\( \\vec{E} \\perp \\vec{B} \\) fields (E \u00d7 B drift) \ud83e\uddee Python Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Physical constants and particle properties q = 1.6e-19 # charge [C] m = 9.11e-31 # mass [kg] (electron) E = np.array([0, 0, 0]) # Electric field [V/m] B = np.array([0, 0, 1]) # Magnetic field [T] v0 = np.array([1e6, 0, 1e6]) # Initial velocity [m/s] r0 = np.array([0, 0, 0]) # Initial position [m] # Simulation parameters dt = 1e-11 # time step [s] steps = 1000 # Initialize arrays r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 # Euler method to simulate motion for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i+1] = v[i] + a * dt r[i+1] = r[i] + v[i+1] * dt # Plotting 3D trajectory fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], lw=2) ax.set_xlabel('x [m]') ax.set_ylabel('y [m]') ax.set_zlabel('z [m]') ax.set_title('Trajectory of a Charged Particle (Lorentz Force)') plt.tight_layout() plt.show() \u2699\ufe0f Parameter Exploration You can experiment with different parameters to observe how they affect the particle's motion: Magnetic Field ( B ) : Set B = [0, 0, 1] to observe circular/helical motion. Try reversing the field direction ( B = [0, 0, -1] ) to see the impact on trajectory direction. Electric Field ( E ) : Add E = [1e5, 0, 0] with B = [0, 0, 1] to generate drift motion. Use crossed fields to observe the E \u00d7 B drift . Initial Velocity ( v0 ) : Aligned with B \u2192 pure helical path. Perpendicular to B \u2192 circular motion. Oblique \u2192 spiral motion. Mass and Charge : For protons : m = 1.67e-27 kg , q = 1.6e-19 C For electrons : m = 9.11e-31 kg , q = -1.6e-19 C \ud83d\udccc Important Concepts \ud83d\udd01 Larmor Radius (Cyclotron Radius): \\[ r_L = \\frac{mv_\\perp}{|q|B} \\] The radius of the circular path a charged particle follows in a magnetic field. \ud83d\udd01 Cyclotron Frequency: \\[omega_c = \\frac{|q|B}{m} \\] Describes how quickly the particle rotates around the magnetic field lines. \ud83d\udd01 E \u00d7 B Drift Velocity: \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\] In crossed electric and magnetic fields, particles drift in a direction perpendicular to both. \ud83d\udcca Results & Applications Field Configuration Motion Type Real-world Application $$\\vec{B} $$only Circular / Helical Cyclotrons, magnetic confinement in plasmas $$ \\vec{E} + \\vec{B} $$ Helical + Drift Plasma propulsion, charged beam control $$ \\vec{E} \\perp \\vec{B} $$ E \u00d7 B Drift Hall effect sensors, mass spectrometers \u2705 Conclusion The Lorentz force provides a powerful model for understanding the dynamics of charged particles in electromagnetic fields. By simulating their motion: We can visualize complex paths like spirals , drifts , and circular orbits . These insights help explain mechanisms in fusion reactors , spacecraft propulsion , and astrophysical phenomena . Tuning parameters such as charge, mass, field strengths, and initial velocities enables exploration of diverse behaviors. Simulations like these are essential tools in both education and real-world physics and engineering applications.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-lorentz-force-simulation","text":"","title":"\u26a1 Electromagnetism: Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force determines the motion of a charged particle in electric and magnetic fields: \\[vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This principle governs systems such as: - Cyclotrons & Synchrotrons (particle accelerators) - Mass spectrometers - Plasma confinement in tokamaks - Astrophysical jets and solar wind interactions By simulating this force, we gain intuitive insight into how fields control particle motion in real applications.","title":"\ud83e\uddf2 Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task-overview","text":"","title":"\ud83d\udd27 Task Overview"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-applications-of-lorentz-force","text":"System Role of E and B fields Cyclotron Uses a B field to bend paths and an E field to accelerate particles Mass Spectrometer Separates particles based on mass-to-charge ratio using B field Plasma Confinement Magnetic fields trap hot plasma in fusion devices like tokamaks","title":"1. Applications of Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-particle-motion-simulation","text":"We solve: \\[ \\frac{d\\vec{v}}{dt} = \\frac{q}{m} (\\vec{E} + \\vec{v} \\times \\vec{B}), \\quad \\frac{d\\vec{r}}{dt} = \\vec{v} \\] Using numerical integration (Euler or Runge-Kutta), we simulate 3 cases: Uniform magnetic field (circular/helical motion) Uniform electric + magnetic fields (helical drift) Crossed \\( \\vec{E} \\perp \\vec{B} \\) fields (E \u00d7 B drift)","title":"2. Particle Motion Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Physical constants and particle properties q = 1.6e-19 # charge [C] m = 9.11e-31 # mass [kg] (electron) E = np.array([0, 0, 0]) # Electric field [V/m] B = np.array([0, 0, 1]) # Magnetic field [T] v0 = np.array([1e6, 0, 1e6]) # Initial velocity [m/s] r0 = np.array([0, 0, 0]) # Initial position [m] # Simulation parameters dt = 1e-11 # time step [s] steps = 1000 # Initialize arrays r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 # Euler method to simulate motion for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i+1] = v[i] + a * dt r[i+1] = r[i] + v[i+1] * dt # Plotting 3D trajectory fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], lw=2) ax.set_xlabel('x [m]') ax.set_ylabel('y [m]') ax.set_zlabel('z [m]') ax.set_title('Trajectory of a Charged Particle (Lorentz Force)') plt.tight_layout() plt.show()","title":"\ud83e\uddee Python Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameter-exploration","text":"You can experiment with different parameters to observe how they affect the particle's motion: Magnetic Field ( B ) : Set B = [0, 0, 1] to observe circular/helical motion. Try reversing the field direction ( B = [0, 0, -1] ) to see the impact on trajectory direction. Electric Field ( E ) : Add E = [1e5, 0, 0] with B = [0, 0, 1] to generate drift motion. Use crossed fields to observe the E \u00d7 B drift . Initial Velocity ( v0 ) : Aligned with B \u2192 pure helical path. Perpendicular to B \u2192 circular motion. Oblique \u2192 spiral motion. Mass and Charge : For protons : m = 1.67e-27 kg , q = 1.6e-19 C For electrons : m = 9.11e-31 kg , q = -1.6e-19 C","title":"\u2699\ufe0f Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#important-concepts","text":"","title":"\ud83d\udccc Important Concepts"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#larmor-radius-cyclotron-radius","text":"\\[ r_L = \\frac{mv_\\perp}{|q|B} \\] The radius of the circular path a charged particle follows in a magnetic field.","title":"\ud83d\udd01 Larmor Radius (Cyclotron Radius):"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#cyclotron-frequency","text":"\\[omega_c = \\frac{|q|B}{m} \\] Describes how quickly the particle rotates around the magnetic field lines.","title":"\ud83d\udd01 Cyclotron Frequency:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#e-b-drift-velocity","text":"\\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\] In crossed electric and magnetic fields, particles drift in a direction perpendicular to both.","title":"\ud83d\udd01 E \u00d7 B Drift Velocity:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#results-applications","text":"Field Configuration Motion Type Real-world Application $$\\vec{B} $$only Circular / Helical Cyclotrons, magnetic confinement in plasmas $$ \\vec{E} + \\vec{B} $$ Helical + Drift Plasma propulsion, charged beam control $$ \\vec{E} \\perp \\vec{B} $$ E \u00d7 B Drift Hall effect sensors, mass spectrometers","title":"\ud83d\udcca Results &amp; Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"The Lorentz force provides a powerful model for understanding the dynamics of charged particles in electromagnetic fields. By simulating their motion: We can visualize complex paths like spirals , drifts , and circular orbits . These insights help explain mechanisms in fusion reactors , spacecraft propulsion , and astrophysical phenomena . Tuning parameters such as charge, mass, field strengths, and initial velocities enables exploration of diverse behaviors. Simulations like these are essential tools in both education and real-world physics and engineering applications.","title":"\u2705 Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 \ud83d\udd0c Circuits Problem 1: Equivalent Resistance Using Graph Theory \ud83c\udfaf Motivation Calculating equivalent resistance is a foundational concept in circuit analysis. While traditional methods (series/parallel reduction) work well for small circuits, they can become tedious and error-prone for complex networks. By applying graph theory , we can model any circuit as a weighted graph : - Nodes \u2192 electrical junctions - Edges \u2192 resistors (weights = resistance values) This method: - Enables automated analysis and simplification - Provides deeper understanding of circuit structure - Is suitable for integration in simulation tools and optimizers \u2705 Task Options \ud83e\udde9 OPTION 1: Simplified Task \u2013 Algorithm Description Describe how to compute equivalent resistance using graph theory Provide pseudocode : Identify series and parallel patterns Iteratively reduce the circuit Handle nested combinations of resistors \ud83d\udcbb OPTION 2: Advanced Task \u2013 Full Implementation Implement the full algorithm in a language like Python Use graph libraries like networkx for circuit representation Ensure that your program: Accepts circuit graphs Handles arbitrary resistor networks Produces the total equivalent resistance Include test cases: Series and parallel Nested configurations Complex circuits with cycles \ud83e\udde0 Algorithm Outline ```plaintext function calculate_equivalent_resistance(graph, source, target): while graph has more than 2 nodes: for each node n in graph: if n is neither source nor target: if n has exactly 2 neighbors: perform series reduction elif node is part of a simple cycle: perform parallel reduction return resistance between source and target","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuits","text":"","title":"\ud83d\udd0c Circuits"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1-equivalent-resistance-using-graph-theory","text":"","title":"Problem 1: Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a foundational concept in circuit analysis. While traditional methods (series/parallel reduction) work well for small circuits, they can become tedious and error-prone for complex networks. By applying graph theory , we can model any circuit as a weighted graph : - Nodes \u2192 electrical junctions - Edges \u2192 resistors (weights = resistance values) This method: - Enables automated analysis and simplification - Provides deeper understanding of circuit structure - Is suitable for integration in simulation tools and optimizers","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-options","text":"","title":"\u2705 Task Options"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-1-simplified-task-algorithm-description","text":"Describe how to compute equivalent resistance using graph theory Provide pseudocode : Identify series and parallel patterns Iteratively reduce the circuit Handle nested combinations of resistors","title":"\ud83e\udde9 OPTION 1: Simplified Task \u2013 Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-2-advanced-task-full-implementation","text":"Implement the full algorithm in a language like Python Use graph libraries like networkx for circuit representation Ensure that your program: Accepts circuit graphs Handles arbitrary resistor networks Produces the total equivalent resistance Include test cases: Series and parallel Nested configurations Complex circuits with cycles","title":"\ud83d\udcbb OPTION 2: Advanced Task \u2013 Full Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-outline","text":"```plaintext function calculate_equivalent_resistance(graph, source, target): while graph has more than 2 nodes: for each node n in graph: if n is neither source nor target: if n has exactly 2 neighbors: perform series reduction elif node is part of a simple cycle: perform parallel reduction return resistance between source and target","title":"\ud83e\udde0 Algorithm Outline"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 \ud83d\udcca Exploring the Central Limit Theorem through Simulations \ud83c\udfaf Motivation The Central Limit Theorem (CLT) is a cornerstone of probability and statistics. It states that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the population\u2019s original distribution. This powerful concept explains why the normal distribution appears so frequently in practice. Simulations provide an intuitive and hands-on way to observe this phenomenon. \u2705 Task Overview 1. Simulating Sampling Distributions Select several types of population distributions , such as: Uniform distribution Exponential distribution Binomial distribution For each distribution, generate a large population dataset (e.g., size = 100,000). 2. Sampling and Visualization For each population: Randomly draw samples of different sizes : \\( n = 5, 10, 30, 50 \\) Compute the sample mean for each sample Repeat this process many times (e.g., 1000 repetitions) Plot histograms of the sample means to form sampling distributions Observe how the distributions of the sample means converge to normal as \\( n \\) increases. 3. Parameter Exploration Investigate how the shape of the original population affects the rate of convergence Explore how the variance of the population influences the spread of the sampling distribution Compare different distributions side-by-side for better insights 4. Practical Applications of CLT Discuss the importance of CLT in real-world contexts: \ud83d\udcd0 Estimating unknown population parameters (e.g., means in surveys) \ud83c\udfed Quality control and manufacturing \ud83d\udcc8 Predictive modeling in finance and economics \ud83d\udc0d Python Code import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set seed for reproducibility np.random.seed(42) # Generate a uniform population population = np.random.uniform(0, 10, size=100_000) # Sampling settings sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Plot plt.figure(figsize=(12, 10)) for i, n in enumerate(sample_sizes): sample_means = [np.mean(np.random.choice(population, size=n, replace=False)) for _ in range(num_samples)] plt.subplot(2, 2, i+1) sns.histplot(sample_means, bins=30, kde=True, color='skyblue') plt.title(f'Sampling Distribution (n={n})') plt.xlabel('Sample Mean') plt.ylabel('Frequency') plt.tight_layout() plt.suptitle('CLT in Action: Uniform Distribution', fontsize=16, y=1.02) plt.show()","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"\ud83d\udcca Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a cornerstone of probability and statistics. It states that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the population\u2019s original distribution. This powerful concept explains why the normal distribution appears so frequently in practice. Simulations provide an intuitive and hands-on way to observe this phenomenon.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-overview","text":"","title":"\u2705 Task Overview"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"Select several types of population distributions , such as: Uniform distribution Exponential distribution Binomial distribution For each distribution, generate a large population dataset (e.g., size = 100,000).","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"For each population: Randomly draw samples of different sizes : \\( n = 5, 10, 30, 50 \\) Compute the sample mean for each sample Repeat this process many times (e.g., 1000 repetitions) Plot histograms of the sample means to form sampling distributions Observe how the distributions of the sample means converge to normal as \\( n \\) increases.","title":"2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"Investigate how the shape of the original population affects the rate of convergence Explore how the variance of the population influences the spread of the sampling distribution Compare different distributions side-by-side for better insights","title":"3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications-of-clt","text":"Discuss the importance of CLT in real-world contexts: \ud83d\udcd0 Estimating unknown population parameters (e.g., means in surveys) \ud83c\udfed Quality control and manufacturing \ud83d\udcc8 Predictive modeling in finance and economics","title":"4. Practical Applications of CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set seed for reproducibility np.random.seed(42) # Generate a uniform population population = np.random.uniform(0, 10, size=100_000) # Sampling settings sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Plot plt.figure(figsize=(12, 10)) for i, n in enumerate(sample_sizes): sample_means = [np.mean(np.random.choice(population, size=n, replace=False)) for _ in range(num_samples)] plt.subplot(2, 2, i+1) sns.histplot(sample_means, bins=30, kde=True, color='skyblue') plt.title(f'Sampling Distribution (n={n})') plt.xlabel('Sample Mean') plt.ylabel('Frequency') plt.tight_layout() plt.suptitle('CLT in Action: Uniform Distribution', fontsize=16, y=1.02) plt.show()","title":"\ud83d\udc0d Python Code"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 \ud83e\ude80 Physics Experiment Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum \ud83c\udfaf Motivation The acceleration due to gravity, denoted g , is a key constant in physics. This experiment uses a simple pendulum to measure g and emphasizes: - Accurate measurement techniques - Uncertainty analysis - Comparison with the standard value: $$ g_{\\text{standard}} = 9.806 \\, \\text{m/s}^2 $$ \ud83e\uddea Materials String (length: ~1\u20131.5 m) Small weight (e.g., metal washer, keychain) Stopwatch or smartphone Measuring tape or ruler \ud83d\udd27 Setup Attach the weight to the string and suspend from a fixed point. Measure pendulum length from the pivot to the center of mass of the weight: $$ L = \\text{m}, \\quad \\Delta L = \\frac{\\text{resolution}}{2} = \\text{m} $$ \ud83d\udcca Data Collection Trial Time for 10 Oscillations (T\u2081\u2080) [s] 1 __ 2 __ 3 __ 4 __ 5 __ 6 __ 7 __ 8 __ 9 __ 10 __ \ud83e\uddee Calculations: Mean Time for 10 Oscillations: $$ \\bar{T} {10} = \\frac{\\sum T {10}}{10} = \\text{__} \\, {s} $$ Standard Deviation (s): $$ s = \\sqrt{\\frac{1}{n-1} \\sum (T_{10,i} - \\bar{T}_{10})^2} = \\text{s} $$ Uncertainty in Mean Time (\u0394T\u2081\u2080): $$ \\Delta \\bar{T}_{10} = \\frac{s}{\\sqrt{n}} = \\text{s} $$ Period of Pendulum (T): $$ T = \\frac{\\bar{T} {10}}{10} = \\text{__} \\, \\text{s}, \\quad \\Delta T = \\frac{\\Delta \\bar{T} {10}}{10} $$ Calculate g: $$ g = \\frac{4\\pi^2 L}{T^2} = \\text{__} \\, \\text{m/s}^2 $$ \ud83d\udcc9 Uncertainty Propagation \\[ \\frac{\\Delta g}{g} = \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\quad \\Rightarrow \\quad \\Delta g = g \\cdot \\frac{\\Delta g}{g} = \\text{__} \\, \\text{m/s}^2 \\] Final result: $$ g = \\boxed{\\text{ } \\pm \\text{ } \\, \\text{m/s}^2} $$ \ud83e\udde0 Discussion 1. Comparison with Standard Value Measured vs. expected value: $$ g_{\\text{measured}} \\quad \\text{vs.} \\quad g_{\\text{standard}} = 9.806 \\, \\text{m/s}^2 $$ Is the standard value within your uncertainty range? 2. Sources of Uncertainty Measurement error in length $$ \\Delta L $$ Human reaction time in timing $$ \\Delta T $$ Assumption of small angle$$ (<15\u00b0)$$ Air resistance and friction 3. Experimental Limitations Difficulty in timing exactly 10 oscillations Non-rigid or stretching string Assumption of a point mass \ud83d\udce6 Conclusion This experiment demonstrates how a simple pendulum can be used to measure gravitational acceleration using basic tools and rigorous uncertainty analysis. By comparing the result to the standard value of 9.806 m/s\u00b2 , one can assess experimental accuracy and understand the importance of error propagation in physical measurements.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#physics-experiment","text":"","title":"\ud83e\ude80 Physics Experiment"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1-measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity, denoted g , is a key constant in physics. This experiment uses a simple pendulum to measure g and emphasizes: - Accurate measurement techniques - Uncertainty analysis - Comparison with the standard value: $$ g_{\\text{standard}} = 9.806 \\, \\text{m/s}^2 $$","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"String (length: ~1\u20131.5 m) Small weight (e.g., metal washer, keychain) Stopwatch or smartphone Measuring tape or ruler","title":"\ud83e\uddea Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#setup","text":"Attach the weight to the string and suspend from a fixed point. Measure pendulum length from the pivot to the center of mass of the weight: $$ L = \\text{m}, \\quad \\Delta L = \\frac{\\text{resolution}}{2} = \\text{m} $$","title":"\ud83d\udd27 Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-collection","text":"Trial Time for 10 Oscillations (T\u2081\u2080) [s] 1 __ 2 __ 3 __ 4 __ 5 __ 6 __ 7 __ 8 __ 9 __ 10 __","title":"\ud83d\udcca Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"Mean Time for 10 Oscillations: $$ \\bar{T} {10} = \\frac{\\sum T {10}}{10} = \\text{__} \\, {s} $$ Standard Deviation (s): $$ s = \\sqrt{\\frac{1}{n-1} \\sum (T_{10,i} - \\bar{T}_{10})^2} = \\text{s} $$ Uncertainty in Mean Time (\u0394T\u2081\u2080): $$ \\Delta \\bar{T}_{10} = \\frac{s}{\\sqrt{n}} = \\text{s} $$ Period of Pendulum (T): $$ T = \\frac{\\bar{T} {10}}{10} = \\text{__} \\, \\text{s}, \\quad \\Delta T = \\frac{\\Delta \\bar{T} {10}}{10} $$ Calculate g: $$ g = \\frac{4\\pi^2 L}{T^2} = \\text{__} \\, \\text{m/s}^2 $$","title":"\ud83e\uddee Calculations:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-propagation","text":"\\[ \\frac{\\Delta g}{g} = \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\quad \\Rightarrow \\quad \\Delta g = g \\cdot \\frac{\\Delta g}{g} = \\text{__} \\, \\text{m/s}^2 \\] Final result: $$ g = \\boxed{\\text{ } \\pm \\text{ } \\, \\text{m/s}^2} $$","title":"\ud83d\udcc9 Uncertainty Propagation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion","text":"","title":"\ud83e\udde0 Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-comparison-with-standard-value","text":"Measured vs. expected value: $$ g_{\\text{measured}} \\quad \\text{vs.} \\quad g_{\\text{standard}} = 9.806 \\, \\text{m/s}^2 $$ Is the standard value within your uncertainty range?","title":"1. Comparison with Standard Value"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-sources-of-uncertainty","text":"Measurement error in length $$ \\Delta L $$ Human reaction time in timing $$ \\Delta T $$ Assumption of small angle$$ (<15\u00b0)$$ Air resistance and friction","title":"2. Sources of Uncertainty"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-experimental-limitations","text":"Difficulty in timing exactly 10 oscillations Non-rigid or stretching string Assumption of a point mass","title":"3. Experimental Limitations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#conclusion","text":"This experiment demonstrates how a simple pendulum can be used to measure gravitational acceleration using basic tools and rigorous uncertainty analysis. By comparing the result to the standard value of 9.806 m/s\u00b2 , one can assess experimental accuracy and understand the importance of error propagation in physical measurements.","title":"\ud83d\udce6 Conclusion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}